/// \file
/// File Name:                      dump_training_data.cpp \n
/// Date created:                   Wed Jan 18 2017 \n
/// Engineers:                      Conor Gardner \n
/// Special Compile Instructions:   --std=c++11 \n
/// Compiler:                       g++ \n
/// Target OS:                      Ubuntu Linux 16.04 \n
/// Target architecture:            x86 64-bit \n */

#include <fstream>
#include <iostream>
#include <string>

/// \brief Open (overwrite) a python files to dump training data to and write
/// out the prologue of the files.
/// \return true on success and false otherwise
bool open_py_training_data
(
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a set of 9 pixels from
    /// source_matrix_temperature used to compute the corresponding output
    /// pixel.  This will also be the name of the python array written to this
    /// file.  Use only alphanumeric characters and underscores.
    const std::string& source_name,
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a single pixel from
    /// destination_matrix_temperature.  This will also be the name of the
    /// python array written to this file.  Use only alphanumeric characters and
    /// underscores.
    const std::string& destination_name,
    
    /// [in] The number of pixels in a single row of
    /// source_matrix_temperature and destination_matrix_temperature
    unsigned width,
    
    /// [in] The number of pixels in a single column of
    /// source_matrix_temperature and destination_matrix_temperature
    unsigned height,
    
    /// [in] The number of time steps (grids) you are planning to dump.  This
    /// is usually the number of iterations in a simulation
    unsigned num_time_steps
    
){
    
    /// Open file for training data
    std::string source_filename = source_name + ".py";
    std::ofstream source_file(source_filename.c_str());
    if (!source_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << source_filename
            << "\" for writing.\n";
        return false;
    }
    
    // Open file for training outputs
    std::string destination_filename = destination_name + ".py";
    std::ofstream destination_file(destination_filename.c_str());
    if (!destination_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << destination_filename
            << "\" for writing.\n";
        return false;
    }
    
    unsigned linear_size = width * height;
    
    // Write the headers of the training files
    source_file
        << "# Training data generated by tracing rodinia_3.1/cuda/hotspot.cu\n"
           "# This is a 2D array of input temperature tiles at different\n"
           "# time steps.  The first dimension indexes an entire temperature\n"
           "# grid at a particular time.  The next dimension indexes a set of\n"
           "# 9 input pixels within a single time step.\n"
           "# The corresponding output pixels are saved in \""
        << destination_filename
        << "\"\n\n# "
        << source_name
        <<"[num_time_steps][pixels_per_grid]\n"
        << "num_time_steps = "
        << num_time_steps
        << "\npixels_per_grid = "
        << linear_size
        << "\nsource_filename = \""
        << source_filename
        << "\"\ndestination_filename = \""
        << destination_filename
        << "\"\n"
        << source_name
        << "[num_time_steps][pixels_per_grid][9] = [\n";
        
//    destination_file
//        << "# Training data generated by tracing rodinia_3.1/cuda/hotspot.cu\n"
//           "# Each element in this array consists of a single output pixel\n"
//           "# that should be used as a training input for a neural net.\n"
//           "# The training inputs can be found in \""
//        << destination_filename
//        << "\"\n"
//        << destination_name
//        << "_size = "
//        << linear_size
//        << "\n"
//        << destination_name
//        << " = [\n";
    
    return true;
    
}

/// \brief Open (append) a python files to dump training data to and write
/// out the epilogue of the files.
/// \return true on success and false otherwise
bool close_py_training_data
(
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a set of 9 pixels from
    /// source_matrix_temperature used to compute the corresponding output
    /// pixel.  This will also be the name of the python array written to this
    /// file.  Use only alphanumeric characters and underscores.
    const std::string& source_name,
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a single pixel from
    /// destination_matrix_temperature.  This will also be the name of the
    /// python array written to this file.  Use only alphanumeric characters and
    /// underscores.
    const std::string& destination_name
    
){
    
    /// Open file for training data
    std::string source_filename = source_name + ".py";
    std::ofstream source_file(source_filename.c_str(), std::ios_base::app);
    if (!source_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << source_filename
            << "\" for writing.\n";
        return false;
    }
    
    // Open file for training outputs
    std::string destination_filename = destination_name + ".py";
    std::ofstream destination_file(destination_filename.c_str(), std::ios_base::app);
    if (!destination_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << destination_filename
            << "\" for writing.\n";
        return false;
    }
    
    // Close Python arrays
    source_file << "]\n";
    destination_file << "]\n";
    
    return true;
    
}

/// \brief Create a log of each 3x3 input pixel and corresponding output pixel
/// as a python array to be consumed by tensorflow.  Python files are opened
/// in append mode.
/// See hotspot.cu::calculate_temp
/// \return The number of training elements written (aka the number of numbers
/// written to the destinaion file).
unsigned dump_py_training_data
(
    
    /// [in] Row-major array of grid-points used as an input to the temperature
    /// calculator
    const float* source_temperature_matrix,
    
    /// [in] Row-major array of grid points which represents one time step after
    /// source_matrix_temperature generated by 
    const float* destination_temperature_matrix,
    
    /// [in] The number of pixels in a single row of
    /// source_matrix_temperature and destination_matrix_temperature
    unsigned width,
    
    /// [in] The number of pixels in a single column of
    /// source_matrix_temperature and destination_matrix_temperature
    unsigned height,
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a set of 9 pixels from
    /// source_matrix_temperature used to compute the corresponding output
    /// pixel.  This will also be the name of the python array written to this
    /// file.  Use only alphanumeric characters and underscores.
    const std::string& source_name,
    
    /// [in] The name of a file to open and overwrite with a python array of
    /// training data where each training point is a single pixel from
    /// destination_matrix_temperature.  This will also be the name of the
    /// python array written to this file.  Use only alphanumeric characters and
    /// underscores.
    const std::string& destination_name
    
){
    
    /// Open file for training inputs
    std::string source_filename = source_name + ".py";
    std::ofstream source_file(source_filename.c_str(), std::ios_base::app);
    if (!source_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << source_filename
            << "\" for writing.\n";
        return 0;
    }
    
    // Open file for training outputs
    std::string destination_filename = destination_name + ".py";
    std::ofstream destination_file(destination_filename.c_str(), std::ios_base::app);
    if (!destination_file.good())
    {
        std::cerr
            << "Error.  Failed to open \""
            << destination_filename
            << "\" for writing.\n";
        return 0;
    }
    
    // We will ignore border pixels for similicity.  Abort if the image contains
    // only border pixels.
    if (width < 2 || height < 2)
        return 0;
    
    source_file << "[\n";
    destination_file << "[\n";
    
    // Ignore border pixels for simplicity
    unsigned bound_x = width - 1;
    unsigned last_x = width - 2;
    unsigned last_y = height - 2;
    for (unsigned iy = 1, bound_y = height - 1; iy < bound_y; iy++)
    {
        
        unsigned offset = iy * width;
        const float* source_row_above = source_temperature_matrix + (offset - width);
        const float* source_row_locus = source_temperature_matrix + offset;
        const float* source_row_below = source_temperature_matrix + (offset + width);
        const float* destination_row = destination_temperature_matrix + offset;
        for (unsigned ix = 1; ix < bound_x; ix++)
        {
            
            source_file
                << '['
                << source_row_above[ix - 1] << ", " << source_row_above[ix] << ", " << source_row_above[ix + 1] << ", "
                << source_row_locus[ix - 1] << ", " << source_row_locus[ix] << ", " << source_row_locus[ix + 1] << ", "
                << source_row_below[ix - 1] << ", " << source_row_below[ix] << ", " << source_row_below[ix + 1] << ']';
            destination_file << destination_row[ix];
            
            // This is really inefficient to put this check inside the loop
            // feel free to hoist it out of the loop if you're bored.
            if (ix != last_x || iy != last_y)
            {
                source_file << ',';
                destination_file << ',';
            }
            
            source_file << '\n';
            destination_file << '\n';
            
        }
        
    }
    
    source_file << ']';
    destination_file << ']';
    
    // Return the number of training elements written
    return (width - 2) * (height - 2);
    
}

